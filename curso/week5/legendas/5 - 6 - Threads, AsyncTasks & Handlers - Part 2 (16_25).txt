The next threading support class that we'll discuss is the AsyncTask class. This class provides a general framework for managing tasks, that, as in our previous examples, involve work that has to be shared between a background thread and the UI thread. The general work flow that you follow when you're using an Async task, is that work is divided between a background thread and the UI thread. 

The background thread performs the long running operation, and can optionally report its progress. The UI Thread on the other hand, is responsible for the initial setup of the long running operation. It's responsible for publishing intermediate progress information, should the background thread report any, and it's responsible for completing the operation after the background thread has done its work. 

AsyncTask is a generic class. It takes three type of parameters, Params, Progress, and Result. Params is the type of the parameters that are input to the As-, to the AsyncTask. Progress is the type of any intermediate progress reports, and result is the type of the result that is computed by the Async task. The workflow of an Async task goes as follows, first, the onPreExecute method is run in the UI thread before the doInBackground method starts. 

OnPreExecute will usually set up the long running operation. After that, the doInBackground method does the bulk of the operation in the background thread. And this method takes a variable list of input parameters and it returns a result of type result. Now, while doInBackground is running, it can optionally call the publishProgress method, passing in a variable list of values which presumably provide some indication of the long running operations progress. If the background thread makes calls to publishProgress, then some calls to onProgressUpdate would normally be made in the UI thread, as long as the background thread is still running. 

And finally, onPostExecute will be called in the UI thread with the result, with the result returned by the background thread as its parameter. Let's look at a version of our icon loading application implemented with an Async task.  Here I'll start up the thread Async task application. It looks similar to the previous examples, but I've added a new UI element, a progress bar that represents how much of the bitmap loading has been done already. 

So, here I'll press the Load Icon button, and you can see that a small progress bar has appeared and it's slowly getting filled in. I'll now press the Other Button and we see the familiar text pop up, and finally, there's the bitmap. Let's look at the source code for this application. Here I will start up the threadAsycTask application. Now I'll open the main activity file. 

And here I'm displaying the button listener for the load icon button. This code creates a new instance of the load icon task. And then calls execute on it, passing in the icon's resource ID as a parameter. So let's look at the LoadIconTask class in more detail. LoadIconTask is an Async task and its type parameters are integer for params, integer for progress, and bitmap for the result. 

The first method we'll look at is onPreExecute. This method is executed in the UI thread, and it's purpose is to make a progress bar visible on the display. The next method is doInBackground. This method receives an integer as a parameter. This integer is the resource ID for the bitmap that was passed in to the load icon task's execute method. 

DoInBbackground does the work of loading the bitmap. As it does this, it periodically calls publishProgress, passing in an integer which represents the percentage of the loading that's been done so far. And again, this example's a bit contrived in the hope of keeping things simple. The example might have been a bit more realistic though, if we were downloading an image from the internet, or if we were waiting for the result from a database query, but hopefully this still gives you a good flavor of how Async tasks work. 

The next method is onProgressUpdate. This method runs in the UI thread, receives the integer that was passed into publishProgress, and then sets the progress bar to reflect the percentage of work done. And finally, the last method is onPostExecute. This method, again, runs in the UI thread, and it receives the just loaded bitmap as a parameter. 

It first makes the progress bar invisible, since that's no longer needed, and then it sets the loaded bitmap on the image view. The last thing I want to talk about in this lesson is the Handler class. Like the Async task, the Handler class is designed to support handing off work between two threads. 

The Handler class is more flexible, however, in that it will work for any two threads, not just for a background thread and the UI thread. A Handler is associated with a specific thread. One thread can hand off work to another thread by sending messages or by posting Runnables to a Handler that's associated with that other thread. So first, let's discuss messages and runnables, and then we'll get into the architecture of the Handler class itself. 

Now, you already know about runnables. You use these when the sender knows exactly what work steps it wants performed, but it wants that work performed on the Handler's thread. A message, on the other hand, is a class that can contain data such as a message code, an arbitrary data object, and some integer values. 

And you use messages when the sender thread wants to indicate an operation that should be done in another thread, but it leaves the implementation of that operation to the Handler itself. So, now let's talk about how Handlers use these messages and runnables. Each Android thread is associated with a MessageQueue and a Looper. 

The MessageQueue is a data structure. It holds messages and runnables. The Looper takes these messages and runnables off of the MessageQueue and dispatches them as appropriate. Now this graphic depicts a thread a, that has created a runnable. And that has used a Handler object to post that runnable to the Handler's thread. When thread A does this, a runnable is placed on the MessageQueue of the thread associated with the Handler. 

Now something pretty similar happens with messages. And this graphic depicts a thread B that has created a message, and that is used a Handler's, a handler's sendMessage method to send that message to the Handler's thread. When thread B does this, the message is placed on the MessageQueue associated with that Handler. Now, while all this is going on, the Looper object is sitting there, just waiting for work to appear on the MessageQueue. 

And when that work does appear, the Looper reacts in one of two ways, depending on the kind of work that has just arrived. Now, If that work is a message, the Looper will handle the message by calling the Handler's handleMessage method, and passing in the message itself. If instead, that work is a runnable, then the Looper will handle it by simply calling, that runnable's, run method. 

Now, here are some of the methods that you use when posting runnables to a Handler. We've already seen the post method, there are a number of other methods that allow you to schedule work for execution at different times. For instance, you can use the postAtTime method to add a runnable to the MessageQueue, but to run it at a specific time. 

There is also a postDelayed method, and that allows you to add a runnable to the MessageQueue, but to run it after a specified delay. If you want to send messages, you first need to create the message. One way to do that is to use the Handler's ObtainMessage method, which gives you a message with the Handler already set. 

You can also use the message class's obtain method. And once you have the message, you'll want to set the data for the message. There are a number of variations for doing this so please check out the documentation. As with runnables, there are a number of methods that you can use to send the message. There is the sendMessage method that we just talked about. 

There's also a version that allows you to put the message at the front of the MessageQueue to have it execute as soon as possible. There's a sendMessageAtTime method to queue the message according to the specified time. There's also a sendMessageDelayed method that queues the message at the current time plus the specified delay. Let's look at the source code for versions of our running example that were implemented using Handlers. 

Here's the ThreadingHandlerRunnable application. I'll now open up this application's main activity. And first, you see that this code is creating a new Handler. This Handler will be created by the main UI thread. So the runnables that this Handler receives will be executed in the UI thread. Now, here I'm showing you the button listener for the load icon button. When the user presses the load icon button, this code creates and starts a new thread, whose run method is defined by the runnable load icon task. Let's look at that class. 

Now this run method begins by posting a new runnable that when executed, will make the progress bar visible. It continues by loading the bitmap. And while it's doing that, it periodically publishes its progress by posting another runnable that calls setProgress on the progress bar. It then posts a runnable that sets the newly loaded bitmap on the display. And it finishes by posting a last runnable, then makes the progress bar invisible. 

Let's also look at a second version of this application that send messages, instead of posting runnables. Here's the ThreadingHandlerMessages application. I'll now open up this application's main activity. And first, you see that this code is creating a new Handler. And again, this Handler will be created by the main UI thread. The work that this Handler performs will be executed in the UI thread. 

As you can see, this Handler has a handleMessage method, in which it implements the various kinds of work. This method starts by checking the message code that's in the message. And then, it takes the appropriate action for that message code. For instance, if the code is set_progress_bar_visibility, then this code sets the visibility status of the progress bar. If the code is instead progress_update, then this code sets the progress state on the progress bar. 

If the code is set_bitmap, then the code sets the bitmap on the display. Now, let's go to the button listener for the load icon button. Same as before, when the user presses the load icon button, this code creates and starts a new thread whose run method is defined by the runnable loadIcon task. And this run method begins by obtaining a message with the code set to set_progress_bar_visibility, and with an argument indicating that the progress bar should be made visible. 

It then sends that message to the Handler, which will handle it, and make the progress bar visible. It then continues by loading the bitmap. And while it's doing that, it periodically publishes progress by obtaining and sending a message with the code progress_update, and with an argument that indicates the percent, the percentage of work done. 

This will result in the Handler calling setProgress on the progress bar. It then obtains and sends a message to set the newly loaded bitmap on the display. And finally, it sends a last message to make the progress bar invisible. So that's all for this lesson on threads, Async tasks, and Handlers. Please join me next time when we'll talk about alarms. Thank you.  