So far, our example application has requested data and then just displayed that data in a TextView. But as you saw, that data has a complex format that's really intended for machine processing and not for displaying to human beings. In fact, this is an increasingly popular way to transport data around the internet and many web services now provide data in such formats. 

In particular, two formats that we'll talk about now are the JavaScript Object Notation, JSON and the Extensible Markup Language, XML. Let's talk about each of these, one at a time. The first format we'll talk about is the JavaScript Object Notation, JSON. This format is intended to be lightweight and resembles the data structures found in traditional programming languages. JSON data is packaged in two kinds of data structures. 

One, maps, which are essentially sets of key and value pairs. And two, ordered lists. If you want more details about JSON, please take a look at this website. Now, let's go back our example application. As you remember, that application made a request to a web service, for some data about earthquakes. Well, the response that came back was actually formatted in JSON. So here's that date and let's break it apart. First, the data comprises a JSON object and that object is a map and that map has one key value pair. 

The key is called earthquakes. And the value is an ordered list. Now that list has several objects inside it. And each of those objects is itself a map. And each of those maps again, contains key valued pairs. For instance, there's a key called eqid and it's value is an earthquake ID. There's also a key called lng and it's value is the longitude at which the earthquake was centered. And there are a bunch of other keys, as well. And together, all of these values provide the data for one earthquake. 

Let's take a look at an example application that gets this data from the internet and then processes it to create a more human, readable display. So here's my device and now I'll launch the networking Android HTTP client JSON application. As before, this application initially displays a single button labeled Load Data. And as before, when I press that button, the application will issue an HTTP get request to an external server. 

And that server will respond, with some complex text, containing the requested earthquake data. This time however, the data will be summarized and presented, in a list view. Okay, so now I'll press the Load Data button. And, there you can see the requested data, summarized and presented in a list view. Let's look at the source code, to see how this works. Here I've got the application open in the IDE. 

And now, I'll open up the file that does the downloading and displaying. And I'm going to skip right to the HTTP GetTask class. Now here, the doInBackground method is similar to what we've seen before, but this time, it uses the JSON response handler class to process the response. Let's scroll down and take a look at that class. The key method in this class is the handle response method. 

This method begins, by passing the raw response through a basic response handler which just returns the response body without the http response headers. Next, the code uses a JSON tokener to parse the JSON response into a Java object. And then to return that top-level object, which in this case is a map. Next, the code extracts the value associated with the earthquake's key. 

And in this case, that's an ordered list. Next, the code iterates over the earthquakes' list and for each element of that list, it gets the data associated with a single earthquake. And this data is stored in Maps. Next, the code summarizes the various pieces of earthquake data, converting them to a single string and adding that string to a list, called result. 

And then finally the result is returned back to the calling method. Now, after the doInBackground method finishes the onPostExecute method is called. And it's provided the result as its parameter. And as you can see, this method creates and sets a list adapter for the list view, passing in the result list that was computed back in handle response. 

The second data format that we'll talk about is the Extensible Markup Language, XML. XML is a markup language for creating XML documents. XML documents contain markup and content. The markup encodes a description of the document's storage layout and logical structure. The content is everything else. And in particular, that content comprises the response data when XML is used to encode an http response. Now, if you want more details about XML, please take a look at this website. 

Now, let's go back to our example application. If we give a slightly different URL then that web service will return the earthquake data in XML format rather than in JSON format. So, here's that data, let's break it apart. First there's an element called geonames. Nested inside that element, is a series of earthquake elements. And each of the earthquake elements contains other elements that provide the data for one earthquake. 

So comparable to what we saw with the JSON format, there's an element called eqid and its value is an earthquake ID. There's also the lng element, and its value is the longitude at which the earthquake was centered. And just like in the JSON example, there are a bunch of other elements, as well. So if our application gets XML data from the internet, it will need to parse the XML document so it can create the list view display that we saw earlier. 

Android provides several different types of XML parsers, including DOM parsers. DOM stands for Document Object Model. And DOM parsers read the entire XML document and convert it into a document model structure, a tree. And then the application does its processing on this tree structure. Now this kind of parser requires more memory, but does allow the application to do things like multi-pass processing of the document. SAX parsers. 

These parsers read the XML document as a stream and as they encounter various document entities, they call back into the application, which can then process the document's information. Now, these parsers use less memory than DOM parsers, but they're limited to doing their processing in a single pass of the document. Pull parsers, like SAX parsers read the document as a stream. But Pull parsers use an iterator based approach. 

Where the application, rather than the parser decides when to move the parsing process along. And like SAX parsers, Pull parsers also use less memory than DOM parsers do. But Pull parsers also give the application greater control over the parsing process than SAX parsers do. Now, the example application looks exactly the same as the one we showed for parsing JSON responses. So, I won't show this application to you now. 

Instead, let's look at this application's source code. Now here I've opened the application in the IDE. And now, I'll open up the file that does the downloading and displaying. And again, I'm going to skip right to the HTTP GetTask class. The doInBackground method, similar to what we have seen before, but now it uses the XML response handler class, to process the response. 

So let's open up that class and see how it works. Now as before, the key method in this class is the handle response method. And this method begins by creating the PullParser object. Next, the code sets the parser's input to be the XML document that was returned in the body of the http response. And after that, the code gets the first parser event, and then begins to iterate over the XML document. 

Now, inside the while loop, there are three events that this code checks for: seeing the start of an XML tag, seeing the end of an XML tag and seeing element content. Now, when the event is a start event, The start tag method is called passing in the element that is being started. This method identifies, if this data element is one that needs to be saved. 

And if so, it records that by setting certain variables. When the event is an end event, the end tag method is called. Passing in the element that is being ended and again, this method identifies whether this data element is one that's being saved and if so, it records that. In addition, if this is the end of the earthquake tag, then the results string for this piece of earthquake data is added to the result list. 

When the event is a text event, the text method is called, passing in the element's content. This method identifies which tag is currently being parsed and then saves the content for later use. And, as before, after the doInBackground method finishes the onPostExecute method is called with the result passed in as the parameter. 

And that method creates and sets a list adapter for the list view passing in the result list that was computed back in handle response. So that's all for our lesson on networking. See you next time for a lesson on graphics and animation. Bye for now.  